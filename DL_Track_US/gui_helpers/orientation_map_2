import time

import cv2
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
import numpy as np
import pandas as pd
from curved_fascicles_functions import (
    adapted_contourEdge,
    adapted_filter_fascicles,
    crop,
    do_curves_intersect,
    find_next_fascicle,
)
from curved_fascicles_prep import apo_to_contour, fascicle_to_contour
from matplotlib.patches import Rectangle

# load image as gray scale image
image = cv2.imread(
    r"C:\Users\carla\Documents\Master_Thesis\Example_Images\FALLMUD\NeilCronin\fascicle_masks\img_00118.tif",
    cv2.IMREAD_UNCHANGED,
)
apo_image = cv2.imread(
    r"C:\Users\carla\Documents\Master_Thesis\Example_Images\FALLMUD\NeilCronin\aponeurosis_masks\img_00118.jpg",
    cv2.IMREAD_UNCHANGED,
)
original_image = cv2.imread(
    r"C:\Users\carla\Documents\Master_Thesis\Example_Images\FALLMUD\NeilCronin\images\img_00118.tif",
    cv2.IMREAD_UNCHANGED,
)

original_image, image, apo_image = crop(original_image, image, apo_image)

# get sorted fascicle contours
image_gray, contoursF, contours_sorted = fascicle_to_contour(image)

# get extrapolation of aponeuroses
apo_image_gray, ex_x_LA, ex_y_LA, ex_x_UA, ex_y_UA = apo_to_contour(apo_image)

# get contours around detected fascicles
contour_image = cv2.cvtColor(
    image_gray, cv2.COLOR_GRAY2BGR
)  # Convert to BGR for visualization
cv2.drawContours(contour_image, contoursF, -1, (0, 255, 0), 2)  # Draw contours in green

# get upper edge of each contour
contours_sorted_x = []
contours_sorted_y = []
for i in range(len(contours_sorted)):
    contours_sorted[i][0], contours_sorted[i][1] = adapted_contourEdge(
        "B", contours_sorted[i]
    )
    contours_sorted_x.append(contours_sorted[i][0])
    contours_sorted_y.append(contours_sorted[i][1])

new_x = []
new_y = []

for i in range(len(contours_sorted_x)):
    if len(contours_sorted_x[i]) > 1:
        coefficients = np.polyfit(contours_sorted_x[i], contours_sorted_y[i], 2)
        g = np.poly1d(coefficients)
        ex_current_fascicle_x = np.linspace(contours_sorted_x[i][0], contours_sorted_x[i][-1], 100)  # Extrapolate x,y data using f function
        ex_current_fascicle_y = g(ex_current_fascicle_x)
        new_x.append(ex_current_fascicle_x)
        new_y.append(ex_current_fascicle_y)

num_grid_lines = 40
height, width, _ = original_image.shape
x_spacing = width // num_grid_lines
y_spacing = height // num_grid_lines

all_coordsXY = list(zip(new_x, new_y))
for i in range(len(all_coordsXY)):
    all_coordsXY[i] = list(zip(all_coordsXY[i][0], all_coordsXY[i][1]))

num_rows = height // y_spacing + 1
num_cols = width // x_spacing + 1
m_matrix = pd.DataFrame([[[] for _ in range(num_cols)] for _ in range(num_rows)])

for idx in range(len(all_coordsXY)):

    curve_coords = np.array(all_coordsXY[idx])
    grid_cells = pd.DataFrame([[[] for _ in range(num_cols)] for _ in range(num_rows)])

    for point in curve_coords:
        x, y = point
        if 0 <= x <= width and 0 <= y <= height:
            grid_x = x // x_spacing
            grid_y = y // y_spacing
            grid_cells.at[grid_y, grid_x].append((x, y))

    for i in range(len(grid_cells)):
        for j in range(len(grid_cells)):
            if grid_cells.at[i, j]:
                x_start = grid_cells.at[i, j][0][0]
                y_start = grid_cells.at[i, j][0][1]
                x_end = grid_cells.at[i, j][-1][0]
                y_end = grid_cells.at[i, j][-1][1]
                dx = x_end - x_start
                dy = y_start - y_end
                m = dy / dx
                if m < 1:
                    m_matrix.at[i, j].append(m)

shape = (len(m_matrix), len(m_matrix))
m_matrix_total = np.zeros(shape)

for i in range(len(m_matrix)):
    for j in range(len(m_matrix)):
        if m_matrix.at[i, j]:
            cell_values = m_matrix.at[i, j]
            cell_length = len(cell_values)
            cell_sum = sum(cell_values)
            cell_mean = cell_sum / cell_length
            m_matrix_total[i, j] = cell_mean

plt.figure(1)
plt.imshow(m_matrix_total, cmap="viridis", interpolation="none")
plt.colorbar(label="Value")
plt.title("Matrix Heatmap")
plt.xlabel("Column")
plt.ylabel("Row")
#plt.show()

for i in range(len(m_matrix_total)):

    values = m_matrix_total[i, :]
    non_zero_indices = np.nonzero(values)[0]
    non_zero_values = values[non_zero_indices]
    
    if len(non_zero_values) > 1:
        interp_func = interp1d(non_zero_indices, non_zero_values, kind='linear', fill_value="extrapolate")

        all_indices = np.arange(len(values))

        m_matrix_total[i, :] = interp_func(all_indices)

plt.figure(2)
plt.imshow(m_matrix_total, cmap="viridis", interpolation="none")
plt.colorbar(label="Value")
plt.title("Matrix Heatmap")
plt.xlabel("Column")
plt.ylabel("Row")
plt.show()
